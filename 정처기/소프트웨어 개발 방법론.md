# 소프트웨어 개발 방법론

## 소프트웨어 생명 주기 모델

### 소프트웨어 생명 주기 모델 개념

- 시스템의 요구 분석부터 유지보수까지 전 공정을 체계화한 절차
- 시스템이 개발될 때부터 운용과 유지보수를 거쳐 생애를 마칠 때까지 어떠한 순서를 밟는지 작업 프로세스를 모델화한 것

### 소프트웨어 생명 주기 모델 프로세스

- 순서: 요구 사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수

1. **요구 사항 분석**
   - 다양한 이해관계자의 요구 사항을 고려하여 새로운 제품이나 변경된 제품에 부합하는 요구와 조건을 결정
   - 개발할 소프트웨어의 기능, 제약 조건, 목표 등을 소프트웨어 사용자와 명확히 정의
   - 활동: 기능 요구 사항, 비기능 요구 사항
2. **설계**
   - 시스템 명세 단계에서 정의한 기능을 실제 수행할 수 있도록 수행 방법을 논리적으로 결정
   - 활동: 시스템 구조 설계, 프로그램 설계, 사용자 인터페이스 설계
3. **구현**
   - 설계 단계에서 논리적으로 결정한 문제 해결 방법을 특정 프로그래밍 언어를 사용하여 실제 프로그램을 작성
   - 프로그래밍 언어 선택, 기법, 스타일, 순서 등을 결정
   - 활동: 인터페이스 개발, 자료 구조 개발, 오류 처리
4. **테스트**
   - 시스템이 정해진 요구를 만족하는지, 예상과 실제 결과가 어떤 차이를 보이는 검사하고 평가
   - 활동: 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트
5. **유지보수**
   - 시스템이 인수되고 설치한 후 일어나는 모든 활동
   - 활동: 예방, 완전, 교정, 적응, 유지보수

### 소프트웨어 생명 주기 모델 종류

1. **폭포수 모델**
   - 소프트웨어 개발 시 각 단계를 확실히 마무리 지은 후 다음 단계로 넘어가는 모델
   - 가장 오래됨
   - 선형 순차적 모형 -> 고전적 생명 주기 모델
   - 모형의 적용 겅험과 성공 사례가 많음
   - 단계별 정의와 산출물이 명확
   - 요구 사항 변경이 어려움
   - 절차: 타당성 검토 -> 계획 -> 요구 사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
2. **프로토타이핑 모델**
   - 고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어 가는 모델
   - 프로토타입은 발주자나 개발자 모두에게 공동의 참조 모델 제공
   - 프로토타입은 구현 단계의 구현 골격
3. **나선형 모델**
   - 시스템 개발 시 위험을 최소화하기 위하여 점진적으로 완벽한 시스템으로 개발해 나가는 모델
   - 절차: 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가 (계위개고)
4. **반복적 모델**
   - 구축 대상을 나누어 병렬적으로 개발 후 통합하거나 반복적으로 개발하여 점증 완성시키는 SDLC 모델
   - 사용자의 요구 사항 일부분 혹은 제품 일부분을 반복적으로 개발하여 최종 시스템으로 완성하는 모델

- 모델 간 비교
  - **폭포수 모델**
    - 절차도: 요구 사항 분석 -> 설계 -> 구현 -> 테스트
    - 순차적 접근
    - 장점: 이해 용이, 관리 편리
    - 단점: 요구 사항 변경 어려움
  - **프로토타이핑 모델**
    - 절차도: 요구 사항 분석 -> 프로토타입 개발 -> 프로토타입 평가 -> 구현 -> 테스트
      - 프로토타입 평가에서 요구 사항 분석으로 다시 되돌아 가기도 함
    - 프로토타입 개발
    - 장점: 요구 분석 용이, 타당성 검증 가능
    - 단점: 프로토타입 폐기에 따른 비용 증가
  - **나선형 모델**
    - 절차도: 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가 -> 계획 및 정의.. (계위개고)
    - <u>위험 분석</u>, 반복 개발
    - 장점: 위험성 감소, 변경에 유연한 대처
    - 단점: 단계 반복에 따른 관리 어려움
  - **반복적 모델**
    - 개발 대상 -> 분석 -> 설계 -> 구현
    - 증분 방식으로 병행 개발
    - 장점: 병행 개발로 인한 일정 단축 가능
    - 단점: 병행 개발에 따른 관리 비용 증가

## 소프트웨어 개발 방법론

### 소프트웨어 개발 방법론 개념

- 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법
- 소프트웨어를 하나의 생명체로 간주하고 소프트웨어 개발의 시작부터 시스템을 사용하지 않는 과정까지의 전 과정 형상화한 방법론

### 소프트에어 개발 방법론 종류

1. **구조적 방법론**
   - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식
   - 프로세스 중심의 하향식 방법론
   - 구조적 프로그랠밍 표현을 위해 나씨-슈나이더만 차트 사용
   - 나씨 슈나이더만 차트
     - 논리의 기술에 중점을 둔 도형식 표현 방법
     - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현
     - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합
2. **정보 공학 방법론**
   - 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
   - 개발 주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
3. **객체 지향 방법론**
   - '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론
   - 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용하는 방법론
   - 객체, 클래스, 메시지 사용
4. **컴포넌트 기반 방법론** (CBD: Component Based Development)
   - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
   - 개발 기간 단축으로 인한 생산성 향상
   - 새로운 기능 추가 쉬움 (확장성)
   - 소프트웨어 재사용 가능
5. **애자일 방법론**
   - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론
   - 개발 과정의 어려움을 극복하기 위해 적극적으로 모색한 방법론
6. **제품 계열 방법론**
   - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
   - 임베디드 소프트웨어를 작성하는 데 유용
   - 영역 공학과 응용 공학으로 구분
   - 영역 공학: 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역
   - 응용 공학: 제품 요구 분석, 제품 설계, 제품을 구현하는 영역

### 애자일

#### 개념

- 절차보다는 사람 중심으로 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론
- 개발 기간이 짧고 신속하며, 폭포수 모형에 대비되는 방법론으로 개발과 함께 피드백을 받아 유동적으로 개발 가능

#### 등장 배경

- 기존 개발 방법론의 한계 극복
  - 전통적 방법론은 문서 및 절차 위주로 변화에 신속한 대응이 어려움
  - 빠르게 적응하고 효율적으로 개발할 수 있는 방법론의 필요성 증가
- 소프트웨어 개발 환경의 변화
  - 소프트웨어 개발 트렌드가 모바일 환경으로 변화
  - 시장 적시성과 잦은 배포의 중요성 부각

#### 유형

1. **XP (eXtreme Programming)**

- 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론

- 1~3주의 반복(iteration) 개발 주기

- 5가지 가치와 12개의 실천 항목 존재

- 5가지 가치

  - 용기 (Courage)

    용기를 가지고 자신감 있게 개발(코드를 작성하기 전에 테스트, 빠르게 피드백, 테스트에 부합하지 못하는 코드를 리팩토링할 수 있는 용기)

  - 단순성 (Simplicity)

    필요한 것만 하고 그 이상의 것들은 하지 않음

  - 의사소통 (Communication)

    개발자, 관리자, 고객 간 원활한 소통

  - 피드백 (Feedback)

    의사소통에 대한 빠른 피드백

  - 존중 (Respect)

    팀원 간 상호 존중

- 12가지 기본 원리

  - 짝 프로그래밍 (Pair Programming)

    개발자 둘이서 짝으로 코딩하는 원리

  - 공동 코드 소유 (Collective Ownership)

    시스템에 있는 코드는 누구든지 언제라도 수정 가능하다는 원리

  - 지속적인 통합 (CI; Continuous Integration)

    매일 여러 번씩 소프트웨어를 통합하고 빌드해야 한다는 원리

  - 계획 세우기 (Planning Process)

    고객이 요구하는 비즈니스 가치를 정의하고, 개발자가 필요한 것은 무엇이며 어떤 부분에서 지연될 수 있는지를 알려 주어야 한다는 원리

  - 작은 릴리즈 (Small Release)

    작은 시스템을 먼저 만들고, 짧은 단위로 업데이트한다는 원리

  - 메타포어 (Metaphor)

    공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자 간의 의사소통을 원활하게 한다는 원리

  - 간단한 디자인

    현재의 요구 사항에 적합한 가장 단순한 시스템을 설계한다는 원리

  - <u>테스트 기반 개발</u> (TDD: Test Driven Development)

    작성해야 하는 프로그램에 대한 테스트를 먼저 수행하고 이 테스트릍 통과할 수 있도록 실제 프로그램의 코드를 작성한다는 원리

  - <u>리팩토링</u> (Refactoring)

    프로그램의 기능을 바꾸지 않으면서 중복 제거, 단순화 등을 위해 시스템 재구성한다는 원리

  - 40시간 작업 (40-Hour Work)

    개발자가 피곤으로 인해 실수하지 않도록 일주일에 40시간 이상을 일하지 말아야 한다는 원리

  - 고객 상주 (On Site Customer)

    개발자들의 질문에 즉각 대답해 줄 수 있는 고객을 프로젝트에 풀타임으로 상주시켜야 한다는 원리

  - 코드 표준 (Coding Standard)

    효과적인 공동 작업응 위해서는 모든 코드에 대한 코딩 표준을 정의해야 한다는 원리

2. 스크럼 (Scrum)
   - 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론
   - 순서: 백로그 분배 -> 스크림 팀 구성 -> 스프린트 회의 -> 스프린트 수행 -> 스크럼 미팅 -> 스프린트 회고
   - 백로그
     - 제품과 프로젝트에 대한 요구 사항
   - 스프린트
     - 2~4주의 짧은 개발 기간으로 반복적 수행으로 개발 품질 향상
   - 스크럼 미팅
     - 매일 15분 정도 미팅으로 투두 리스트 계획 수립
   - 스크럼 마스터
     - 프로젝트 리더, 스크럼 수행 시 문제를 인지 및 해결하는 사람
   - 스프린트 회고
     - 스프린트 주기를 되돌아보며 정해 놓은 규칙 준수 여부, 개선점 등을 확인 및 기록
     - 해당 스프린트가 끝난 시점이나 일정 주기로 시행
   - 번 다운 차트
     - 남아 있는 백로그 대비 시간을 그래픽적으로 표현한 차트
     - 백로그는 보통 수직축에 위치하며 시간은 수평축에 위치
3. 린 (LEAN)
   - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용 -> 낭비 요소를 제거하여 품질 향상
   - JIT(Just In Time), 칸반(Kanban) 보드 사용
   - 7가지 원칙: 낭비 제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화

#### 애자일과 전통적 방법론 비교

- 애자일 방법론
  - 계획 수립: 유동적 범위 설정
  - 업무 수행: 팀 중심 업무 수행
  - 개발/검증: 반복 주기 단위로 소프트웨어를 개발/검증
  - 팀 관리: 업무 몰입, 팀 평가
  - 문서화: 문서화보다는 코드 강조
  - 성공 요소: 고객 가치 전달
  - 유형: XP, 스크럼, 린
- 전통적 방법론
  - 계획 수립: 확정적 범위 설정
  - 업무 수행: 관리자 주도적 명령과 통제, 개인 단위로 업무 수행
  - 개발/검증: 분석/설계/구현/테스트를 순차적으로 수행
  - 팀 관리: 경쟁, 개별 평가
  - 문서화: 상세한 문서화 강조
  - 성공 요소: 계획/일정 준수
  - 유형: 폭포수, 프로토타입, 나선형

## 객체 지향 분석 방법론

### 객체 지향 개념

실세계의 개체를 속성과 메서드가 결합한 형태의 객체로 표현하는 기법

### 객체 지향 구성 요소

1. **클래스**
   - 특정 객체 내에 있는 변수와 메서드를 정의하는 일종의 틀
   - 객체 지향 프로그래밍에서 데이터를 추상화하는 단위
   - 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현
   - 속성은 변수의 형태로, 행위는 메서드의 형태로 선언
2. **객체**
   - 물리적, 추상적으로 자신과 다른 것을 식별 가능한 대상
   - 클래스에서 정의한 것을 토대로 메모리에 할당됨
   - 객체마다 각각의 상태와 식별성을 가짐
3. **메서드**
   - 클래스로부터 생성된 객체를 사용하는 방법
   - 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산
   - 전통적 시스템의 함수(function) 또는 프로시저(procedure)에 해당하는 연산 기능
4. **메시지**
   - 객체 간 상호 작용 위한 수단
   - 객체에게 어떤 행위를 하도록 지시하는 방법
   - 객체 간 상호 작용은 메시지를 통해 이루어짐
   - 메시지는 객체에서 객체로 전달됨
5. **인스턴스**
   - 객체 지향 기법에서 클래스를 통해 만든 실제의 실형 객체
   - 클래스에 속한 각각의 객체
   - 실제로 메모리상에 할당
6. **속성 (property)**
   - 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의
   - 성질, 분류, 식별, 수량, 현재 상황에 대한 표현 값

### 객체 지향 기법

1. **캡슐화** **(Encapsulation)**

   - 서로 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 기법
   - 결합도가 낮아지고 재사용이 용이
   - 인터페이스가 단순화됨
   - 정보 은닉과 관계가 깊음
   - 변경 발생 시 오류의 파급 효과가 적음

2. **상속성 (Inheritance)**

   - 상위 클래스의 속성과 메서드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법

3. **다형성 (Polymorphism)**

   - 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는  능력

   - 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질

   - 오버로딩, 오버라이딩이 대표적

   - **오버로딩 (Overloading)**

     - 매개 변수의 유형과 개수를 다르게 하여 같은 이름의 메서드를 여러 개 가지는 기법

       예) void fn(int a), void fn(char a), void fn(int a, int b)

   - **오버라이딩 (Overriding)**

     - 상위 클래스에서 정의한 일반 메서드의 구현을 하위 클래스에서 무시하고 재정의할 수 있는 기법

       예) class A {

       ​		void fn(int a);

       ​	}

       ​	class B : public A {

       ​		void fn(int a)

       ​	} 

   4. **추상화 (Abstraction)**
      - 공통 성질을 추출하여 추상 클래스를 설정하는 기법
      - 과정 추상화, 자료 추상화, 제어 추상화가 있음
   5. **정보 은닉 (Information Hiding)**
      - 코드 내부 데이터와 메서드를 숨기고 공개 인터페이스를 통해서만 접근이 가능하도록 하는 코드 보안 기술
      - 필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부 시스템이 다른 모듈의 구현에 영향을 받지 않게 설계됨 (Side-Effect 최소화)
      - 모듈 내부의 자료 구조와 접근 동작들에만 수정을 국한하지 않기 때문에 요구 사항 등 변화에 따른 수정 가능
      - 모듈 사이 독립성 유지하는 데 도움을 줌
      - 설계에서 은닉되어야 할 기본 정보로는 IP 주소와 같은 물리적 코드, 상세 데이터 구조 등이 존재
   6. **관계성 (Relationship)**
      - 두 개 이상의 엔티티 형에서 데이터를 참조하는 관계를 나타내는 기법
      - 연관화, 분류화, 집단화, 일반화, 특수화가 있음
      - <u>연관화</u>
        - is-member-of 관계
        - 클래스와 객체의 참조 및 이용 관계
        - 같은 계층에 속하는 클래스들 사이의 상호 의존성을 보여 주는 비계층적 관계성을 나타냄
      - <u>집단화</u>
        - is part of 관계, part-whole 관계
        - 서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체를 만드는 특징이 있음
        - 일반화와 달리 상위 클래스의 성질들이 하위 클래스로 상속되지는 않음
      - <u>분류화</u>
        - is-instance-of 관계
        - 공통된 속성에 의해 정의된 객체 구성원들의 인스턴스
      - <u>일반화</u>
        - is-a 관계
        - 클래스들 간의 개념적인 포함 관계
        - 상위 클래스의 특성을 하위 클래스가 상속받음
      - <u>특수화</u>
        - is-a 관계
        - 상위 클래스의 특성들을 상속받으면서 하위 클래스에서 나름대로 수정을 가하고 자기 자신의 고유한 특성을 갖는 관계

   ### 객체 지향 설계 원칙 (SOLID)

   1. **단일 책임의 원칙 (SRP; Single Responsibility Principle)**
      - 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다
      - 객체 지향 프로그래밍의 5원칙 중 나머지 4원칙의 기초 원칙
   2. **개방 폐쇄 원칙 (OOP: Open Close Principle)**
      - 소프트웨어의 구성 요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다
   3. **리스코프 치환의 원칙 (LSP; Liskov Substitution Principle)**
      - 서브 타입(상속받은 하위 클래스)은 어디서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 한다
   4. **인터페이스 분리의 원칙 (ISP: Interface Segregation Principle)**
      - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다
      - 객체 설계 시 특정 기능에 대한 인터페이스는 그 기능과 상관없는 부분이 변해도 영향을 받지 않아야 한다
   5. **의존성 역전의 법칙 (DIP; Dependency Inversion Principle)**
      - 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만든다

### 객체 지향 분석의 개념

- 객체 지향 분석(OOA; Oriented Analysis)

  사용자의 요구 사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 속성과 연산, 관계를 정의하여 모델링하는 기법

### 객체 지향 분석 방법론 종류

1. 야콥슨, OOSE (Object Oriented Software Engineering)
   - 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용하는 방법론
   - 분석, 설계, 구현 단계로 구성
   - 기능적 요구 사항 중심의 시스템
2. 럼바우, OMT (Object Modeling Technology)
   - 그래픽 표기법을 이용하여 소프트웨어 구성 요소를 모델링하는 방법론
   - 분석 절차: 객체 모델링 -> 동적 모델링 -> 기능 모델링
   - 객체 모델링 (Object Modeling)
     - 정보 모델링이라고도 함
     - 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델링
     - 객체 다이어그램을 활용하여 표현
   - 동적 모델링 (Dynamic Modeling)
     - 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적 행위를 표현하는 모델링
     - 상태 다이어그램을 활용하여 표현
   - 기능 모델링 (Functional Modeling)
     - 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현하는 모델링
     - 자료 흐름도(DFD)를 활용하여 표현
3.  코드-요든(Coad-Yourdon) 방법론
   - E-R 다이어그램 사용하여 객체 행위 모델링
   - 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등을 과정으로 구성
4. 워프-브록(Wirfs-Brock) 방법론
   - 분석과 설계 간 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 분석 방법

### 기능 모델링 주요 기법

#### 데이터 흐름도 (DFD; Data Flow Diagram)

- 데이터 흐름도 개념
  - 데이터가 각 프로세스를 따라 흐르면서 변환되는 모습을 나타낸 그림
  - 시스템 분석과 설계에서 매우 유용하게 사용되는 다이어그램
  - 자료 흐름 그래프 또는 버블(Bubble) 차트라고도 함
- 데이터 흐름도 특징
  - 구조적 분석 기법에 이용
  - 데이터(Data)의 흐름에 중심을 두는 분석용 도구
  - 제어(Control)의 흐름은 중요하지 않다
  - 시간 흐름을 명확하게 표현할 수는 없다

#### 자료 사전 (DD: Data Dictonary)

- 자료 사전 개념
  - 자료 요소, 자료 요소들의 집합, 자료의 흐름, 자료 저장소의 의미와 그들 간의 관계, 관계 값, 범위, 단위들을 구체적으로 명시하는 사전
  - 파일 혹은 데이터베이스에 있는 자료에 대한 자료 또는 각 자료 항목에 주어진 이름과 같이 길이 그리고 서술과 같은 데이터를 포함하는 참조를 위한 작업
- 자료 사전 작성 목적
  - 조직에 속해 있는 다른 사람들에게 특정한 자료 용어가 무엇을 의미하는지 알려 주기 위하여, 용어의 정의를 조정하고 취합하고 문서로 명확히 하는 목적이 있다
  - 자료 흐름도에 나타나는 어떤 자료의 흐름도 자료 사전에 정의되어 있어야 한다

## 프로젝트 관리

### 프로젝트 관리

#### 개념

- 프로젝트 관리는 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동이다
- 프로젝트 관리는 소프트웨어 개발 계획을 세우고 분석, 설계, 구현 등의 작업을 통제하는 것으로 소프트웨어 생명 주기의 전 과정에 걸쳐서 진행된다
- 소프트웨어 프로젝트를 성공적으로 수행하기 위해서는 수행할 작업의 범위, 필요한 자원, 수행 업무, 비용, 추진 일정들을 관리해야 한다

#### 대상

- 계획 관리, 품질 관리, 범위 관리 등
- 계획 관리
  - 프로젝트 계획, 비용 산정, 일정 계획, 조직 계획에 대한 관리
- 품질 관리
  - 품질 통제 및 품질 보증
- 범위 관리
  - 이해 관계자가 요청한 모든 요구 사항이 프로젝트 범위에 포함되었는지 보장하고, 필요한 작업만 수행될 수 있도록 관리

#### 3대 요소

- 사람, 문제, 프로세스
- 사람 (people)
  - 프로젝트 관리에서 가장 기본이 되는 인적 자원
- 문제 (problem)
  - 사용자의 입장에서 문제를 분석하여 인식함
- 프로세스 (process)
  - 소프트웨어 개발에 필요한 전체적인 작업 계획 및 구조 (framework)

### 비용 산정 모형

#### 개념

비용 산정 모형은 소프트웨어 규모 파악을 통한 투입 자원, 소요 시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식

#### 분류

- 하향식 산정 방법과 상향식 산정 방법
- 하향식 산정 방법
  - 경험이 많은 전문가에게 비용 산정을 의뢰하거나 여러 전문가와 조정자를 통해 산정하는 방식
  - 전문가 판단, 델파이 기법
  - 델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래 예측을 위한 기법으로 전문가 합의법이라고도 한다
- 상향식 산정 방법
  - 세부적인 요구 사항과 기능에 따라 필요한 비용을 계산하는 방식
  - 코드 라인 수(Loc), Man Month, COCOMO 모형, 푸트남 모형, 기능 점수(FP) 모형

#### 종류

1. LoC(Lines of Code) 모형
   - LoC 모형은 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 방식
   - 측정이 쉽고 이해하기 쉬워 많이 사용
   - 예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용 산정
   - 예측치 = [낙관치 + (4 * 중간치) + 비관치] / a
   - 비관치: 가장 많이 측정된 코드 라인 수
   - 중간치: 측정된 모든 코드 라인 수의 평균
   - 낙관치: 가장 적게 측정된 코드 라인 수
2. Man Month 모형
   - Man Month 모형은 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
   - Man Month = LoC / 프로그래머의 월간 생산성
   - 프로젝트 기간 = Man Month / 프로젝트 인력
3. COCOMO(COnstructive COst Model) 모형
   - COCOMO 모형은 보헴이 제안한 모형, 프로그램 규모에 따라 비용 산정하는 방식
   - 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)로 산정
   - 비용 견적의 강도 분석 및 비용 견적의 유연성이 높아 소프트웨어 개발비 견적에 널리 통용
   - 규모에 따라 유형이 조직형(=기본형, 단순형), 반 분리형, 임베디드형으로 나뉨
   - 소프트웨어 개발 유형
     - 조직형(Organic Mode)
       - 기관 내부에서 개발된 중소 규모의 소프트웨어로 일괄 자료 처리나 과학 기술 계산용, 비즈니스 자료 처리 개발에 적용
       - 5만(50KDSI) 라인 이하의 소프트웨어를 개발하는 유형
     - 반 분리형(Semi-Detached Mode)
       - 단순형과 임베디드형의 중간형
       - 트랜잭션 처리 시스템, 데이터베이스 관리 시스템, 컴파일러, 인터프리터와 같은 유틸 개발에 적용
       - 30만(300KDSI) 라인 이하의 소프트웨어를 개발하는 유형
     - 임베디드형(Embedded Mode)
       - 초대형 규모의 트랜잭션 처리 시스템이나 운영 체제, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적용
       - 30만(300KDSI) 라인 이상의 소프트웨어를 개발하는 유형
4.  푸트남(Putnam)  모형
   - 푸트남 모형은 소프트웨어 개발 주기의 단계별로 요구할 인력의 분포를 가정하는 방식
   - 푸트남이 제안한 것, 생명 주기 예측 모형이라고도 함
   - 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다
5. 기능 점수(FP; Function Point) 모형
   - 기능 점수 모형은 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식
   - 기능 점수(FP) = 총 기능 점수 * [0.65 + (0.1 * 총 영향도)]
   - 경험을 바탕으로 단순, 보통, 복잡한 정도에 따라 가중치 부여

### 일정 관리 모델

#### 개념

일정 관리 모델은 프로젝트가 일정 기한 내 적절하게 완료될 수 있도록 관리하는 모델

#### 종류

주 공정법, PERT, 중요 연쇄 프로젝트 관리

- 주 공정법(CPM; Critical Path Method)
  - 주 공정(Critical Path; 임계 경로): 프로젝트의 시작에서 종료까지 가장 긴 시간이 걸리는 경로
  - 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 방법
  - 모든 자원 제약 사항을 배제한 상태로 프로젝트의 시작과 끝을 나타내는 노드(node)와 노드 간 연결을 통해 공정을 계산하기 위한 액티비티(Activity) 표기법
- PERT(Program Evaluation and Review Technique)
  - 일의 순서를 계획적으로 정리하기 위한 수렴 기법으로 비관치, 중간치, 낙관치의 3점 추첨 방식을 통해 일정을 관리하는 기법
- 중요 연쇄 프로젝트 관리(CCPM; Critical Chain Project Management)
  - 주 공정 연쇄법으로 자원 제약 사항을 고려하여 일정을 작성하는 기법

### 위험 관리

#### 개념

- 위험 관리는 프로젝트에 내재된 위험 요소를 인식하고 그 영향을 분석하여 이를 관리하는 활동
- 위험 관리는 프로젝트를 성공시키기 위하여 위험 요소를 사전에 예측, 대비하는 모든 기술과 활동 포함

#### 위험 종류

- 소프트웨어 개발 시 나타나는 일반적인 위험 요소에는 인력 부족, 예산 관리, 일정 관리, 사용자 요구 사항 변경 등이 있으며 이중 가장 대표적인 위험 요소는 사용자 요구 사항 변경
- 위험의 종류에는 알려진 위험, 예측 가능한 위험, 예측 불가능한 위험
- 알려진 위험: 프로젝트 계획서, 기술적 환경, 정보 등에 의해 발견될 수 있는 위험
- 예측 가능한 위험: 과거 경험으로부터 예측할 수 있는 위험
- 예측 불가능한 위험: 사전 예측이 매우 어려운 위험

#### 위험 대응 전략

- 회피(Avoidance): 발생 가능성을 원칙적으로 제거하는 전략
- 전가(Transference): 위험에 대한 책임을 제3자에게 넘기는 전략
- 완화(Mitigation): 위험 발생 가능성을 감소시키거나 영향력을 감소시키는 전략
- 수용(Accepetance): 위험을 그대로 받아들이는 전략



